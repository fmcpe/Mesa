diff --git a/.github/workflows/android.yml b/.github/workflows/android.yml
new file mode 100644
index 0000000..5ba94c6
--- /dev/null
+++ b/.github/workflows/android.yml
@@ -0,0 +1,70 @@
+
+name: Build Android
+
+on:
+  [push, pull_request]
+
+# A workflow run is made up of one or more jobs that can run sequentially or in parallel
+jobs:
+  build:
+    strategy:
+      matrix:
+        arch: [ "arm32", "aarch64", "x86_64" ]
+      fail-fast: false
+
+    name: "Build for ${{matrix.arch}}"
+
+    runs-on: ubuntu-20.04
+
+    steps:
+      - uses: actions/checkout@v2
+
+      - name: Build
+        run: |
+          ln -s vulkan_android.pc vulkan.pc
+          sudo apt update
+          sudo apt install -y meson libxrandr-dev libxxf86vm-dev libxcb-*-dev libx11-xcb-dev libxfixes-dev libdrm-dev libx11-dev
+          cp -R /usr/include/X11 include/
+          cp -R /usr/include/xcb include/
+          cp -R /usr/include/GL/* include/GL/
+          pip3 install mako
+          #
+          if [ "${{matrix.arch}}" == "arm32" ]; then
+            export ANDROID_TARGET=armv7a-linux-androideabi
+          elif [ "${{matrix.arch}}" == "aarch64" ]; then
+            export ANDROID_TARGET=aarch64-linux-android
+          elif [ "${{matrix.arch}}" == "x86_64" ]; then
+            export ANDROID_TARGET=x86_64-linux-android
+          fi
+          bash android-cross-file-gen.sh
+          # -Dglx=gallium-xlib \
+          meson "build-android-${{matrix.arch}}" \
+            --prefix=/tmp/mesa \
+            --cross-file "/tmp/generated-cross-file" \
+            --buildtype debug \
+            -Dplatforms=android \
+            -Dplatform-sdk-version=26 \
+            -Dandroid-stub=true \
+            -Dllvm=disabled \
+            -Dxlib-lease=disabled \
+            -Degl=disabled \
+            -Dgbm=disabled \
+            -Dglx=dri \
+            -Dglx-direct=true \
+            -Dopengl=true \
+            -Dosmesa=true \
+            -Dvulkan-drivers= \
+            -Dgallium-drivers=zink \
+            -Dshared-glapi=false
+          ninja -C "build-android-${{matrix.arch}}" install
+          # cp "build-android-${{matrix.arch}}/src/gallium/drivers/mesa/libzinkk.a" /tmp/mesa/lib/
+          rm /tmp/mesa/lib/libOSMesa.so /tmp/mesa/lib/libOSMesa.so.8
+          mv /tmp/mesa/lib/libOSMesa.so.8.0.0 /tmp/mesa/lib/libOSMesa.so.8
+          mv /tmp/mesa/lib/libOSMesa.so.8 /tmp/mesa/lib/libOSMesa_unstripped.so.8
+          # $ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/${ANDROID_TARGET}-strip /tmp/mesa/lib/libOSMesa.so.8
+          # mv /tmp/mesa/lib/libOSMesa.so.8 /tmp/mesa/lib/libOSMesa_8.so
+      - name: Upload libraries
+        uses: actions/upload-artifact@v2
+        with:
+          name: libmesa_${{matrix.arch}}
+          path: /tmp/mesa
diff --git a/.github/workflows/ios.yml b/.github/workflows/ios.yml
new file mode 100644
index 0000000..67efc35
--- /dev/null
+++ b/.github/workflows/ios.yml
@@ -0,0 +1,48 @@
+
+name: Build iOS
+
+on:
+  [push, pull_request]
+
+jobs:
+  build:
+    runs-on: macos-latest
+
+    steps:
+      - uses: actions/checkout@v2
+
+      - name: Build iOS
+        run: |
+          git clone --depth 1 https://github.com/KhronosGroup/MoltenVK
+          ln -s vulkan_ios.pc vulkan.pc
+          brew install meson pkg-config
+          # sudo apt install -y meson libxrandr-dev libxxf86vm-dev libxshmfence-dev libxcb-*-dev libx11-xcb-dev libxfixes-dev libdrm-dev libx11-dev
+          # cp -R /usr/include/X11 include/
+          # cp -R /usr/include/xcb include/
+          # cp -R /usr/include/GL/* include/GL/
+          pip3 install mako
+          # -Dglx=gallium-xlib \
+          # -Dglx=dri
+          meson build-ios-aarch64 \
+            --prefix="/tmp/zink" \
+            --cross-file ios-aarch64 \
+            -Dmoltenvk-dir=../../../../MoltenVK/MoltenVK \
+            -Db_lundef=false \
+            -Dllvm=disabled \
+            -Dxlib-lease=disabled \
+            -Degl=disabled \
+            -Dgbm=disabled \
+            -Dglx=dri \
+            -Dglx-direct=true \
+            -Dopengl=true \
+            -Dosmesa=true \
+            -Dvulkan-drivers= \
+            -Dgallium-drivers=zink
+          ninja -C build-ios-aarch64 install
+          # cp build-ios-aarch64/src/gallium/drivers/zink/libzink.a /tmp/zink/lib/
+          install_name_tool -change /tmp/zink/lib/libglapi.0.dylib @executable_path/Frameworks/libglapi.0.dylib.framework/libglapi.0.dylib -add_rpath @executable_path/Frameworks/libMoltenVK.dylib.framework /tmp/zink/lib/libOSMesa.8.dylib
+      - name: Upload libraries
+        uses: actions/upload-artifact@v2
+        with:
+          name: libzink
+          path: /tmp/zink
diff --git a/.gitignore.rej b/.gitignore.rej
new file mode 100644
index 0000000..a7a5d70
--- /dev/null
+++ b/.gitignore.rej
@@ -0,0 +1,6 @@
+diff a/.gitignore b/.gitignore	(rejected hunks)
+@@ -2,3 +2,4 @@
+ *.pyo
+ *.out
+ build
++build-android-*
diff --git a/android-cross-file-gen.sh b/android-cross-file-gen.sh
new file mode 100644
index 0000000..13dbd7c
--- /dev/null
+++ b/android-cross-file-gen.sh
@@ -0,0 +1,4 @@
+#!/bin/bash
+set -e
+
+envsubst < android-cross-file.tmp > /tmp/generated-cross-file
diff --git a/android-cross-file.tmp b/android-cross-file.tmp
new file mode 100644
index 0000000..848f6dd
--- /dev/null
+++ b/android-cross-file.tmp
@@ -0,0 +1,22 @@
+[binaries]
+ar = '$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar'
+c = ['ccache', '$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/${ANDROID_TARGET}26-clang', '-O3', '-DVK_USE_PLATFORM_ANDROID_KHR', '-fPIC']
+cpp = ['ccache', '$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/${ANDROID_TARGET}26-clang++', '-O3', '-DVK_USE_PLATFORM_ANDROID_KHR', '-fPIC', '-fno-exceptions', '-fno-unwind-tables', '-fno-asynchronous-unwind-tables', '-static-libstdc++']
+c_ld = 'lld'
+cpp_ld = 'lld'
+strip = '$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/${ANDROID_TARGET}26-strip'
+# Android doesn't come with a pkg-config, but we need one for meson to be happy not
+# finding all the optional deps it looks for.  Use system pkg-config pointing at a
+# directory we get to populate with any .pc files we want to add for Android
+pkgconfig = ['env', 'PKG_CONFIG_LIBDIR=.', '/usr/bin/pkg-config']
+
+[host_machine]
+system = 'linux'
+# cpu_family = 'x86_64'
+# cpu = 'amd64'
+
+# ik this is wrong but workaround sanity check
+cpu_family = 'arm'
+cpu = 'armv8'
+
+endian = 'little'
diff --git a/ext/libMoltenVK.tbd b/ext/libMoltenVK.tbd
new file mode 100644
index 0000000..cb9056d
--- /dev/null
+++ b/ext/libMoltenVK.tbd
@@ -0,0 +1,179 @@
+--- !tapi-tbd
+tbd-version:     4
+targets:         [ arm64-ios ]
+uuids:
+  - target:          arm64-ios
+    value:           B6460E6F-C706-348A-95ED-21110EECFEB4
+flags:           [ not_app_extension_safe ]
+install-name:    '@rpath/libMoltenVK.dylib'
+exports:
+  - targets:         [ arm64-ios ]
+    symbols:         [ __ZN3mvk11canReadFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE,
+                       __ZN3mvk12absolutePathERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE,
+                       __ZN3mvk12canWriteFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE,
+                       __ZN3mvk13pathExtensionERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE,
+                       __ZN3mvk14MSLShaderInputC1Ev, __ZN3mvk14MSLShaderInputC2Ev,
+                       __ZN3mvk17pathWithExtensionERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_bS6_,
+                       __ZN3mvk18MSLResourceBindingC1Ev, __ZN3mvk18MSLResourceBindingC2Ev,
+                       __ZN3mvk19SPIRVToMSLConverter7convertERNS_33SPIRVToMSLConversionConfigurationEbbb,
+                       __ZN3mvk19SPIRVToMSLConverter8setSPIRVEPKjm, __ZN3mvk20GLSLToSPIRVConverter7convertE28MVKGLSLConversionShaderStagebb,
+                       __ZN3mvk20GLSLToSPIRVConverter7setGLSLEPKcm, __ZN3mvk20GLSLToSPIRVConverter7setGLSLERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE,
+                       __ZN3mvk20GLSLToSPIRVConverter8setGLSLsERKNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE,
+                       __ZN3mvk27SPIRVToMSLConversionOptions15printMSLVersionEjb,
+                       __ZN3mvk27SPIRVToMSLConversionOptionsC1Ev, __ZN3mvk27SPIRVToMSLConversionOptionsC2Ev,
+                       __ZN3mvk33SPIRVToMSLConversionConfiguration29markAllInputsAndResourcesUsedEv,
+                       __ZN3mvk33SPIRVToMSLConversionConfiguration9alignWithERKS0_,
+                       __ZN3mvk8fileNameERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEb,
+                       __ZN3mvk8readFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERNS0_6vectorIcS5_EERS6_,
+                       __ZN3mvk9writeFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_6vectorIcS5_EERS6_,
+                       __ZNK3mvk14MSLShaderInput7matchesERKS0_, __ZNK3mvk17DescriptorBinding7matchesERKS0_,
+                       __ZNK3mvk18MSLResourceBinding7matchesERKS0_, __ZNK3mvk27SPIRVToMSLConversionOptions7matchesERKS0_,
+                       __ZNK3mvk33SPIRVToMSLConversionConfiguration14isResourceUsedEN3spv14ExecutionModelEjj,
+                       __ZNK3mvk33SPIRVToMSLConversionConfiguration19countShaderInputsAtEj,
+                       __ZNK3mvk33SPIRVToMSLConversionConfiguration25isShaderInputLocationUsedEj,
+                       __ZNK3mvk33SPIRVToMSLConversionConfiguration29stageSupportsVertexAttributesEv,
+                       __ZNK3mvk33SPIRVToMSLConversionConfiguration7matchesERKS0_,
+                       _mvkFormatTypeFromMTLPixelFormat, _mvkFormatTypeFromVkFormat,
+                       _mvkMTLBarrierScopeFromVkAccessFlags, _mvkMTLBlendFactorFromVkBlendFactor,
+                       _mvkMTLBlendOperationFromVkBlendOp, _mvkMTLCPUCacheModeFromVkMemoryPropertyFlags,
+                       _mvkMTLClearColorFromVkClearValue, _mvkMTLClearDepthFromVkClearValue,
+                       _mvkMTLClearStencilFromVkClearValue, _mvkMTLColorWriteMaskFromVkChannelFlags,
+                       _mvkMTLCompareFunctionFromVkCompareOp, _mvkMTLCullModeFromVkCullModeFlags,
+                       _mvkMTLIndexTypeFromVkIndexType, _mvkMTLIndexTypeSizeInBytes,
+                       _mvkMTLLoadActionFromVkAttachmentLoadOp, _mvkMTLMultisampleDepthResolveFilterFromVkResolveModeFlagBits,
+                       _mvkMTLMultisampleStencilResolveFilterFromVkResolveModeFlagBits,
+                       _mvkMTLPixelFormatBlockTexelSize, _mvkMTLPixelFormatBytesPerBlock,
+                       _mvkMTLPixelFormatBytesPerLayer, _mvkMTLPixelFormatBytesPerRow,
+                       _mvkMTLPixelFormatBytesPerTexel, _mvkMTLPixelFormatFromVkFormat,
+                       _mvkMTLPixelFormatIsDepthFormat, _mvkMTLPixelFormatIsPVRTCFormat,
+                       _mvkMTLPixelFormatIsStencilFormat, _mvkMTLPixelFormatIsSupported,
+                       _mvkMTLPixelFormatName, _mvkMTLPrimitiveTopologyClassFromVkPrimitiveTopology,
+                       _mvkMTLPrimitiveTypeFromVkPrimitiveTopology, _mvkMTLRenderStagesFromVkPipelineStageFlags,
+                       _mvkMTLResourceOptions, _mvkMTLSamplerAddressModeFromVkSamplerAddressMode,
+                       _mvkMTLSamplerBorderColorFromVkBorderColor, _mvkMTLSamplerMinMagFilterFromVkFilter,
+                       _mvkMTLSamplerMipFilterFromVkSamplerMipmapMode, _mvkMTLScissorRectFromVkRect2D,
+                       _mvkMTLStencilOperationFromVkStencilOp, _mvkMTLStepFunctionFromVkVertexInputRate,
+                       _mvkMTLStorageModeFromVkMemoryPropertyFlags, _mvkMTLStoreActionFromVkAttachmentStoreOp,
+                       _mvkMTLTessellationPartitionModeFromSpvExecutionMode, _mvkMTLTextureSwizzleChannelsFromVkComponentMapping,
+                       _mvkMTLTextureSwizzleFromVkComponentSwizzle, _mvkMTLTextureTypeFromVkImageType,
+                       _mvkMTLTextureTypeFromVkImageViewType, _mvkMTLTextureUsageFromVkImageUsageFlags,
+                       _mvkMTLTriangleFillModeFromVkPolygonMode, _mvkMTLVertexFormatFromVkFormat,
+                       _mvkMTLVertexStepFunctionFromVkVertexInputRate, _mvkMTLViewportFromVkViewport,
+                       _mvkMTLWindingFromSpvExecutionMode, _mvkMTLWindingFromVkFrontFace,
+                       _mvkMipmapBaseSizeFromLevelSize2D, _mvkMipmapBaseSizeFromLevelSize3D,
+                       _mvkMipmapLevelSizeFromBaseSize2D, _mvkMipmapLevelSizeFromBaseSize3D,
+                       _mvkMipmapLevels, _mvkMipmapLevels2D, _mvkMipmapLevels3D,
+                       _mvkSampleCountFromVkSampleCountFlagBits, _mvkShaderStageFromVkShaderStageFlagBits,
+                       _mvkVkFormatBlockTexelSize, _mvkVkFormatBytesPerBlock, _mvkVkFormatBytesPerLayer,
+                       _mvkVkFormatBytesPerRow, _mvkVkFormatBytesPerTexel, _mvkVkFormatFromMTLPixelFormat,
+                       _mvkVkFormatIsSupported, _mvkVkFormatName, _mvkVkFormatProperties,
+                       _mvkVkImageTypeFromMTLTextureType, _mvkVkImageUsageFlagsFromMTLTextureUsage,
+                       _mvkVkSampleCountFlagBitsFromSampleCount, _mvkVkShaderStageFlagBitsFromMVKShaderStage,
+                       _vkAcquireNextImage2KHR, _vkAcquireNextImageKHR, _vkAllocateCommandBuffers,
+                       _vkAllocateDescriptorSets, _vkAllocateMemory, _vkBeginCommandBuffer,
+                       _vkBindBufferMemory, _vkBindBufferMemory2, _vkBindBufferMemory2KHR,
+                       _vkBindImageMemory, _vkBindImageMemory2, _vkBindImageMemory2KHR,
+                       _vkCmdBeginDebugUtilsLabelEXT, _vkCmdBeginQuery, _vkCmdBeginRenderPass,
+                       _vkCmdBeginRenderPass2, _vkCmdBeginRenderPass2KHR, _vkCmdBindDescriptorSets,
+                       _vkCmdBindIndexBuffer, _vkCmdBindPipeline, _vkCmdBindVertexBuffers,
+                       _vkCmdBlitImage, _vkCmdClearAttachments, _vkCmdClearColorImage,
+                       _vkCmdClearDepthStencilImage, _vkCmdCopyBuffer, _vkCmdCopyBufferToImage,
+                       _vkCmdCopyImage, _vkCmdCopyImageToBuffer, _vkCmdCopyQueryPoolResults,
+                       _vkCmdDebugMarkerBeginEXT, _vkCmdDebugMarkerEndEXT, _vkCmdDebugMarkerInsertEXT,
+                       _vkCmdDispatch, _vkCmdDispatchBase, _vkCmdDispatchBaseKHR,
+                       _vkCmdDispatchIndirect, _vkCmdDraw, _vkCmdDrawIndexed, _vkCmdDrawIndexedIndirect,
+                       _vkCmdDrawIndexedIndirectCount, _vkCmdDrawIndexedIndirectCountAMD,
+                       _vkCmdDrawIndexedIndirectCountKHR, _vkCmdDrawIndirect, _vkCmdDrawIndirectCount,
+                       _vkCmdDrawIndirectCountAMD, _vkCmdDrawIndirectCountKHR, _vkCmdEndDebugUtilsLabelEXT,
+                       _vkCmdEndQuery, _vkCmdEndRenderPass, _vkCmdEndRenderPass2,
+                       _vkCmdEndRenderPass2KHR, _vkCmdExecuteCommands, _vkCmdFillBuffer,
+                       _vkCmdInsertDebugUtilsLabelEXT, _vkCmdNextSubpass, _vkCmdNextSubpass2,
+                       _vkCmdNextSubpass2KHR, _vkCmdPipelineBarrier, _vkCmdPushConstants,
+                       _vkCmdPushDescriptorSetKHR, _vkCmdPushDescriptorSetWithTemplateKHR,
+                       _vkCmdResetEvent, _vkCmdResetQueryPool, _vkCmdResolveImage,
+                       _vkCmdSetBlendConstants, _vkCmdSetDepthBias, _vkCmdSetDepthBounds,
+                       _vkCmdSetDeviceMask, _vkCmdSetDeviceMaskKHR, _vkCmdSetEvent,
+                       _vkCmdSetLineWidth, _vkCmdSetScissor, _vkCmdSetStencilCompareMask,
+                       _vkCmdSetStencilReference, _vkCmdSetStencilWriteMask, _vkCmdSetViewport,
+                       _vkCmdUpdateBuffer, _vkCmdWaitEvents, _vkCmdWriteTimestamp,
+                       _vkCreateBuffer, _vkCreateBufferView, _vkCreateCommandPool,
+                       _vkCreateComputePipelines, _vkCreateDebugReportCallbackEXT,
+                       _vkCreateDebugUtilsMessengerEXT, _vkCreateDescriptorPool,
+                       _vkCreateDescriptorSetLayout, _vkCreateDescriptorUpdateTemplate,
+                       _vkCreateDescriptorUpdateTemplateKHR, _vkCreateDevice, _vkCreateEvent,
+                       _vkCreateFence, _vkCreateFramebuffer, _vkCreateGraphicsPipelines,
+                       _vkCreateIOSSurfaceMVK, _vkCreateImage, _vkCreateImageView,
+                       _vkCreateInstance, _vkCreateMetalSurfaceEXT, _vkCreatePipelineCache,
+                       _vkCreatePipelineLayout, _vkCreatePrivateDataSlotEXT, _vkCreateQueryPool,
+                       _vkCreateRenderPass, _vkCreateRenderPass2, _vkCreateRenderPass2KHR,
+                       _vkCreateSampler, _vkCreateSamplerYcbcrConversion, _vkCreateSamplerYcbcrConversionKHR,
+                       _vkCreateSemaphore, _vkCreateShaderModule, _vkCreateSwapchainKHR,
+                       _vkDebugMarkerSetObjectNameEXT, _vkDebugMarkerSetObjectTagEXT,
+                       _vkDebugReportMessageEXT, _vkDestroyBuffer, _vkDestroyBufferView,
+                       _vkDestroyCommandPool, _vkDestroyDebugReportCallbackEXT, _vkDestroyDebugUtilsMessengerEXT,
+                       _vkDestroyDescriptorPool, _vkDestroyDescriptorSetLayout, _vkDestroyDescriptorUpdateTemplate,
+                       _vkDestroyDescriptorUpdateTemplateKHR, _vkDestroyDevice, _vkDestroyEvent,
+                       _vkDestroyFence, _vkDestroyFramebuffer, _vkDestroyImage, _vkDestroyImageView,
+                       _vkDestroyInstance, _vkDestroyPipeline, _vkDestroyPipelineCache,
+                       _vkDestroyPipelineLayout, _vkDestroyPrivateDataSlotEXT, _vkDestroyQueryPool,
+                       _vkDestroyRenderPass, _vkDestroySampler, _vkDestroySamplerYcbcrConversion,
+                       _vkDestroySamplerYcbcrConversionKHR, _vkDestroySemaphore,
+                       _vkDestroyShaderModule, _vkDestroySurfaceKHR, _vkDestroySwapchainKHR,
+                       _vkDeviceWaitIdle, _vkEndCommandBuffer, _vkEnumerateDeviceExtensionProperties,
+                       _vkEnumerateDeviceLayerProperties, _vkEnumerateInstanceExtensionProperties,
+                       _vkEnumerateInstanceLayerProperties, _vkEnumerateInstanceVersion,
+                       _vkEnumeratePhysicalDeviceGroups, _vkEnumeratePhysicalDeviceGroupsKHR,
+                       _vkEnumeratePhysicalDevices, _vkExportMetalObjectsEXT, _vkFlushMappedMemoryRanges,
+                       _vkFreeCommandBuffers, _vkFreeDescriptorSets, _vkFreeMemory,
+                       _vkGetBufferDeviceAddress, _vkGetBufferDeviceAddressEXT, _vkGetBufferDeviceAddressKHR,
+                       _vkGetBufferMemoryRequirements, _vkGetBufferMemoryRequirements2,
+                       _vkGetBufferMemoryRequirements2KHR, _vkGetBufferOpaqueCaptureAddress,
+                       _vkGetBufferOpaqueCaptureAddressKHR, _vkGetDescriptorSetLayoutSupport,
+                       _vkGetDescriptorSetLayoutSupportKHR, _vkGetDeviceGroupPeerMemoryFeatures,
+                       _vkGetDeviceGroupPeerMemoryFeaturesKHR, _vkGetDeviceGroupPresentCapabilitiesKHR,
+                       _vkGetDeviceGroupSurfacePresentModesKHR, _vkGetDeviceMemoryCommitment,
+                       _vkGetDeviceMemoryOpaqueCaptureAddress, _vkGetDeviceMemoryOpaqueCaptureAddressKHR,
+                       _vkGetDeviceProcAddr, _vkGetDeviceQueue, _vkGetDeviceQueue2,
+                       _vkGetEventStatus, _vkGetFenceStatus, _vkGetIOSurfaceMVK,
+                       _vkGetImageMemoryRequirements, _vkGetImageMemoryRequirements2,
+                       _vkGetImageMemoryRequirements2KHR, _vkGetImageSparseMemoryRequirements,
+                       _vkGetImageSparseMemoryRequirements2, _vkGetImageSparseMemoryRequirements2KHR,
+                       _vkGetImageSubresourceLayout, _vkGetInstanceProcAddr, _vkGetMTLBufferMVK,
+                       _vkGetMTLCommandQueueMVK, _vkGetMTLDeviceMVK, _vkGetMTLTextureMVK,
+                       _vkGetMoltenVKConfigurationMVK, _vkGetPastPresentationTimingGOOGLE,
+                       _vkGetPerformanceStatisticsMVK, _vkGetPhysicalDeviceExternalBufferProperties,
+                       _vkGetPhysicalDeviceExternalBufferPropertiesKHR, _vkGetPhysicalDeviceExternalFenceProperties,
+                       _vkGetPhysicalDeviceExternalFencePropertiesKHR, _vkGetPhysicalDeviceExternalSemaphoreProperties,
+                       _vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, _vkGetPhysicalDeviceFeatures,
+                       _vkGetPhysicalDeviceFeatures2, _vkGetPhysicalDeviceFeatures2KHR,
+                       _vkGetPhysicalDeviceFormatProperties, _vkGetPhysicalDeviceFormatProperties2,
+                       _vkGetPhysicalDeviceFormatProperties2KHR, _vkGetPhysicalDeviceImageFormatProperties,
+                       _vkGetPhysicalDeviceImageFormatProperties2, _vkGetPhysicalDeviceImageFormatProperties2KHR,
+                       _vkGetPhysicalDeviceMemoryProperties, _vkGetPhysicalDeviceMemoryProperties2,
+                       _vkGetPhysicalDeviceMemoryProperties2KHR, _vkGetPhysicalDeviceMetalFeaturesMVK,
+                       _vkGetPhysicalDevicePresentRectanglesKHR, _vkGetPhysicalDeviceProperties,
+                       _vkGetPhysicalDeviceProperties2, _vkGetPhysicalDeviceProperties2KHR,
+                       _vkGetPhysicalDeviceQueueFamilyProperties, _vkGetPhysicalDeviceQueueFamilyProperties2,
+                       _vkGetPhysicalDeviceQueueFamilyProperties2KHR, _vkGetPhysicalDeviceSparseImageFormatProperties,
+                       _vkGetPhysicalDeviceSparseImageFormatProperties2, _vkGetPhysicalDeviceSparseImageFormatProperties2KHR,
+                       _vkGetPhysicalDeviceSurfaceCapabilities2KHR, _vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
+                       _vkGetPhysicalDeviceSurfaceFormats2KHR, _vkGetPhysicalDeviceSurfaceFormatsKHR,
+                       _vkGetPhysicalDeviceSurfacePresentModesKHR, _vkGetPhysicalDeviceSurfaceSupportKHR,
+                       _vkGetPipelineCacheData, _vkGetPrivateDataEXT, _vkGetQueryPoolResults,
+                       _vkGetRefreshCycleDurationGOOGLE, _vkGetRenderAreaGranularity,
+                       _vkGetSemaphoreCounterValue, _vkGetSemaphoreCounterValueKHR,
+                       _vkGetSwapchainImagesKHR, _vkGetVersionStringsMVK, _vkInvalidateMappedMemoryRanges,
+                       _vkMapMemory, _vkMergePipelineCaches, _vkQueueBeginDebugUtilsLabelEXT,
+                       _vkQueueBindSparse, _vkQueueEndDebugUtilsLabelEXT, _vkQueueInsertDebugUtilsLabelEXT,
+                       _vkQueuePresentKHR, _vkQueueSubmit, _vkQueueWaitIdle, _vkResetCommandBuffer,
+                       _vkResetCommandPool, _vkResetDescriptorPool, _vkResetEvent,
+                       _vkResetFences, _vkResetQueryPool, _vkResetQueryPoolEXT, _vkSetDebugUtilsObjectNameEXT,
+                       _vkSetDebugUtilsObjectTagEXT, _vkSetEvent, _vkSetHdrMetadataEXT,
+                       _vkSetMTLTextureMVK, _vkSetMoltenVKConfigurationMVK, _vkSetPrivateDataEXT,
+                       _vkSetWorkgroupSizeMVK, _vkSignalSemaphore, _vkSignalSemaphoreKHR,
+                       _vkSubmitDebugUtilsMessageEXT, _vkTrimCommandPool, _vkTrimCommandPoolKHR,
+                       _vkUnmapMemory, _vkUpdateDescriptorSetWithTemplate, _vkUpdateDescriptorSetWithTemplateKHR,
+                       _vkUpdateDescriptorSets, _vkUseIOSurfaceMVK, _vkWaitForFences,
+                       _vkWaitSemaphores, _vkWaitSemaphoresKHR, _vk_icdGetInstanceProcAddr,
+                       _vk_icdGetPhysicalDeviceProcAddr, _vk_icdNegotiateLoaderICDInterfaceVersion ]
+...
diff --git a/ios-aarch64 b/ios-aarch64
new file mode 100644
index 0000000..e2f88e4
--- /dev/null
+++ b/ios-aarch64
@@ -0,0 +1,19 @@
+[binaries]
+
+ar = 'ar'
+c = ['ccache', 'clang', '-O3', '-DVK_USE_PLATFORM_IOS_MVK', '-DVK_USE_PLATFORM_METAL_EXT', '-DVK_ENABLE_BETA_EXTENSIONS', '-arch', 'arm64', '-isysroot', '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk', '-miphoneos-version-min=12.0', '-fPIC']
+cpp = ['ccache', 'clang++', '-O3', '-DVK_USE_PLATFORM_IOS_MVK', '-DVK_USE_PLATFORM_METAL_EXT', '-DVK_ENABLE_BETA_EXTENSIONS', '-arch', 'arm64', '-isysroot', '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk', '-miphoneos-version-min=12.0', '-fPIC', '-fno-exceptions', '-fno-unwind-tables', '-fno-asynchronous-unwind-tables', '-static-libstdc++']
+c_ld = 'ld'
+cpp_ld = 'ld'
+strip = 'strip'
+# Android doesn't come with a pkg-config, but we need one for meson to be happy not
+# finding all the optional deps it looks for.  Use system pkg-config pointing at a
+# directory we get to populate with any .pc files we want to add for Android
+pkgconfig = 'pkg-config'
+
+[host_machine]
+# or linux?
+system = 'darwin'
+cpu_family = 'arm'
+cpu = 'armv8'
+endian = 'little'
diff --git a/log.pc b/log.pc
new file mode 100644
index 0000000..235f45c
--- /dev/null
+++ b/log.pc
@@ -0,0 +1,4 @@
+Name: log
+Description: Android liblog library
+Version: 1.0
+Libs: -llog
diff --git a/nativewindow.pc b/nativewindow.pc
new file mode 100644
index 0000000..cfe23c0
--- /dev/null
+++ b/nativewindow.pc
@@ -0,0 +1,4 @@
+Name: nativewindow
+Description: Android libnativewindow library
+Version: 1.0
+Libs:
diff --git a/src/gallium/frontends/dri/empty.c b/src/gallium/frontends/dri/empty.c
new file mode 100644
index 0000000..e69de29
diff --git a/src/gallium/frontends/osmesa/osmesa_bufferless.c b/src/gallium/frontends/osmesa/osmesa_bufferless.c
new file mode 100644
index 0000000..8361938
--- /dev/null
+++ b/src/gallium/frontends/osmesa/osmesa_bufferless.c
@@ -0,0 +1,1094 @@
+/*
+ * Copyright (c) 2013  Brian Paul   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+/*
+ * Off-Screen rendering into client memory.
+ * OpenGL gallium frontend for softpipe and llvmpipe.
+ *
+ * Notes:
+ *
+ * If Gallium is built with LLVM support we use the llvmpipe driver.
+ * Otherwise we use softpipe.  The GALLIUM_DRIVER environment variable
+ * may be set to "softpipe" or "llvmpipe" to override.
+ *
+ * With softpipe we could render directly into the user's buffer by using a
+ * display target resource.  However, softpipe doesn't support "upside-down"
+ * rendering which would be needed for the OSMESA_Y_UP=TRUE case.
+ *
+ * With llvmpipe we could only render directly into the user's buffer when its
+ * width and height is a multiple of the tile size (64 pixels).
+ *
+ * Because of these constraints we always render into ordinary resources then
+ * copy the results to the user's buffer in the flush_front() function which
+ * is called when the app calls glFlush/Finish.
+ *
+ * In general, the OSMesa interface is pretty ugly and not a good match
+ * for Gallium.  But we're interested in doing the best we can to preserve
+ * application portability.  With a little work we could come up with a
+ * much nicer, new off-screen Gallium interface...
+ */
+
+
+#include <stdio.h>
+#include <c11/threads.h>
+#include "GL/osmesa.h"
+
+#include "glapi/glapi.h"  /* for OSMesaGetProcAddress below */
+
+#include "pipe/p_context.h"
+#include "pipe/p_screen.h"
+#include "pipe/p_state.h"
+
+#include "util/u_atomic.h"
+#include "util/u_box.h"
+#include "util/u_debug.h"
+#include "util/format/u_format.h"
+#include "util/u_inlines.h"
+#include "util/u_memory.h"
+
+#include "postprocess/filters.h"
+#include "postprocess/postprocess.h"
+
+#include "frontend/api.h"
+#include "state_tracker/st_gl_api.h"
+
+#define GALLIUM_ZINK
+#ifdef GALLIUM_ZINK
+#include "kopper_interface.h"
+struct zink_screen {
+   struct pipe_screen base;
+};
+#endif
+
+
+
+extern struct pipe_screen *
+osmesa_create_screen(void);
+
+
+
+struct osmesa_buffer
+{
+   struct st_framebuffer_iface *stfb;
+   struct st_visual visual;
+   unsigned width, height;
+
+   struct pipe_resource *textures[ST_ATTACHMENT_COUNT];
+
+   void *map;
+
+   struct osmesa_buffer *next;  /**< next in linked list */
+};
+
+
+struct osmesa_context
+{
+   struct st_context_iface *stctx;
+
+   boolean ever_used;     /*< Has this context ever been current? */
+
+   struct osmesa_buffer *current_buffer;
+
+   /* Storage for depth/stencil, if the user has requested access.  The backing
+    * driver always has its own storage for the actual depth/stencil, which we
+    * have to transfer in and out.
+    */
+   void *zs;
+   unsigned zs_stride;
+
+   enum pipe_format depth_stencil_format, accum_format;
+
+   GLenum format;         /*< User-specified context format */
+   GLenum type;           /*< Buffer's data type */
+   GLint user_row_length; /*< user-specified number of pixels per row */
+   GLboolean y_up;        /*< TRUE  -> Y increases upward */
+                          /*< FALSE -> Y increases downward */
+
+   /** Which postprocessing filters are enabled. */
+   unsigned pp_enabled[PP_FILTERS];
+   struct pp_queue_t *pp;
+};
+
+/**
+ * Called from the ST manager.
+ */
+static int
+osmesa_st_get_param(struct st_manager *smapi, enum st_manager_param param)
+{
+   /* no-op */
+   return 0;
+}
+
+static struct st_manager *stmgr = NULL;
+static struct st_api *stapi = NULL;
+
+static void
+destroy_st_manager(void)
+{
+   if (stmgr) {
+      if (stmgr->screen)
+         stmgr->screen->destroy(stmgr->screen);
+      FREE(stmgr);
+   }
+
+   if (stapi && stapi->destroy) {
+      stapi->destroy(stapi);
+   }
+}
+
+static void
+create_st_manager(void)
+{
+   if (atexit(destroy_st_manager) != 0)
+      return;
+
+   stmgr = CALLOC_STRUCT(st_manager);
+   if (stmgr) {
+      stmgr->screen = osmesa_create_screen();
+      stmgr->get_param = osmesa_st_get_param;
+      stmgr->get_egl_image = NULL;
+   }
+
+   stapi = st_gl_api_create();
+}
+
+/**
+ * Create/return a singleton st_manager object.
+ */
+static struct st_manager *
+get_st_manager(void)
+{
+   static once_flag create_once_flag = ONCE_FLAG_INIT;
+
+   call_once(&create_once_flag, create_st_manager);
+
+   return stmgr;
+}
+
+/**
+ * Create/return singleton st_api object.
+ */
+static struct st_api *
+get_st_api(void)
+{
+   get_st_manager();
+   return stapi;
+}
+
+/**
+ * Given an OSMESA_x format and a GL_y type, return the best
+ * matching PIPE_FORMAT_z.
+ * Note that we can't exactly match all user format/type combinations
+ * with gallium formats.  If we find this to be a problem, we can
+ * implement more elaborate format/type conversion in the flush_front()
+ * function.
+ */
+static enum pipe_format
+osmesa_choose_format(GLenum format, GLenum type)
+{
+   switch (format) {
+   case OSMESA_RGBA:
+      if (type == GL_UNSIGNED_BYTE) {
+#if UTIL_ARCH_LITTLE_ENDIAN
+         return PIPE_FORMAT_R8G8B8A8_UNORM;
+#else
+         return PIPE_FORMAT_A8B8G8R8_UNORM;
+#endif
+      }
+      else if (type == GL_UNSIGNED_SHORT) {
+         return PIPE_FORMAT_R16G16B16A16_UNORM;
+      }
+      else if (type == GL_FLOAT) {
+         return PIPE_FORMAT_R32G32B32A32_FLOAT;
+      }
+      else {
+         return PIPE_FORMAT_NONE;
+      }
+      break;
+   case OSMESA_BGRA:
+      if (type == GL_UNSIGNED_BYTE) {
+#if UTIL_ARCH_LITTLE_ENDIAN
+         return PIPE_FORMAT_B8G8R8A8_UNORM;
+#else
+         return PIPE_FORMAT_A8R8G8B8_UNORM;
+#endif
+      }
+      else if (type == GL_UNSIGNED_SHORT) {
+         return PIPE_FORMAT_R16G16B16A16_UNORM;
+      }
+      else if (type == GL_FLOAT) {
+         return PIPE_FORMAT_R32G32B32A32_FLOAT;
+      }
+      else {
+         return PIPE_FORMAT_NONE;
+      }
+      break;
+   case OSMESA_ARGB:
+      if (type == GL_UNSIGNED_BYTE) {
+#if UTIL_ARCH_LITTLE_ENDIAN
+         return PIPE_FORMAT_A8R8G8B8_UNORM;
+#else
+         return PIPE_FORMAT_B8G8R8A8_UNORM;
+#endif
+      }
+      else if (type == GL_UNSIGNED_SHORT) {
+         return PIPE_FORMAT_R16G16B16A16_UNORM;
+      }
+      else if (type == GL_FLOAT) {
+         return PIPE_FORMAT_R32G32B32A32_FLOAT;
+      }
+      else {
+         return PIPE_FORMAT_NONE;
+      }
+      break;
+   case OSMESA_RGB:
+      if (type == GL_UNSIGNED_BYTE) {
+         return PIPE_FORMAT_R8G8B8_UNORM;
+      }
+      else if (type == GL_UNSIGNED_SHORT) {
+         return PIPE_FORMAT_R16G16B16_UNORM;
+      }
+      else if (type == GL_FLOAT) {
+         return PIPE_FORMAT_R32G32B32_FLOAT;
+      }
+      else {
+         return PIPE_FORMAT_NONE;
+      }
+      break;
+   case OSMESA_BGR:
+      /* No gallium format for this one */
+      return PIPE_FORMAT_NONE;
+   case OSMESA_RGB_565:
+      if (type != GL_UNSIGNED_SHORT_5_6_5)
+         return PIPE_FORMAT_NONE;
+      return PIPE_FORMAT_B5G6R5_UNORM;
+   default:
+      return PIPE_FORMAT_NONE;
+   }
+}
+
+
+/**
+ * Initialize an st_visual object.
+ */
+static void
+osmesa_init_st_visual(struct st_visual *vis,
+                      enum pipe_format color_format,
+                      enum pipe_format ds_format,
+                      enum pipe_format accum_format)
+{
+   vis->buffer_mask = ST_ATTACHMENT_FRONT_LEFT_MASK | ST_ATTACHMENT_BACK_LEFT_MASK;
+
+   if (ds_format != PIPE_FORMAT_NONE)
+      vis->buffer_mask |= ST_ATTACHMENT_DEPTH_STENCIL_MASK;
+   if (accum_format != PIPE_FORMAT_NONE)
+      vis->buffer_mask |= ST_ATTACHMENT_ACCUM;
+
+   vis->color_format = color_format;
+   vis->depth_stencil_format = ds_format;
+   vis->accum_format = accum_format;
+   vis->samples = 1;
+}
+
+
+/**
+ * Return the osmesa_buffer that corresponds to an st_framebuffer_iface.
+ */
+static inline struct osmesa_buffer *
+stfbi_to_osbuffer(struct st_framebuffer_iface *stfbi)
+{
+   return (struct osmesa_buffer *) stfbi->st_manager_private;
+}
+
+
+/**
+ * Called via glFlush/glFinish.  This is where we copy the contents
+ * of the driver's color buffer into the user-specified buffer.
+ */
+static bool
+osmesa_st_framebuffer_flush_front(struct st_context_iface *stctx,
+                                  struct st_framebuffer_iface *stfbi,
+                                  enum st_attachment_type statt)
+{
+   OSMesaContext osmesa = OSMesaGetCurrentContext();
+   struct osmesa_buffer *osbuffer = stfbi_to_osbuffer(stfbi);
+   struct pipe_resource *res = osbuffer->textures[statt];
+//   unsigned bpp;
+//   int dst_stride;
+
+   if (statt != ST_ATTACHMENT_BACK_LEFT)
+      return false;
+
+   if (osmesa->pp) {
+      struct pipe_resource *zsbuf = NULL;
+      unsigned i;
+
+      /* Find the z/stencil buffer if there is one */
+      for (i = 0; i < ARRAY_SIZE(osbuffer->textures); i++) {
+         struct pipe_resource *res = osbuffer->textures[i];
+         if (res) {
+            const struct util_format_description *desc =
+               util_format_description(res->format);
+
+            if (util_format_has_depth(desc)) {
+               zsbuf = res;
+               break;
+            }
+         }
+      }
+
+      /* run the postprocess stage(s) */
+      //pp_run(osmesa->pp, res, res, zsbuf);
+   }
+
+   //assert(!"FIXME: swap the swapchain");
+   struct pipe_screen *screen = get_st_manager()->screen;
+
+   //printf("BACK_LEFT: %p\n", osbuffer->textures[ST_ATTACHMENT_BACK_LEFT]);
+   //printf("FRONT_LEFT: %p\n", osbuffer->textures[ST_ATTACHMENT_FRONT_LEFT]);
+
+   //osmesa_st_framebuffer_flush_front
+
+   //printf("screen->flush_frontbuffer = %p\n", screen->flush_frontbuffer);
+   stctx->pipe->flush_resource(stctx->pipe, res); //osbuffer->textures[ST_ATTACHMENT_BACK_LEFT]
+   ((struct zink_screen *)screen)->base.flush_frontbuffer(screen, stctx->pipe, res, 0, 0, NULL /* drawable */, NULL /* sub_box */);
+
+   osbuffer->textures[ST_ATTACHMENT_BACK_LEFT] = osbuffer->textures[ST_ATTACHMENT_FRONT_LEFT];
+   osbuffer->textures[ST_ATTACHMENT_FRONT_LEFT] = res;
+
+   /* Snapshot the color buffer to the user's buffer. */
+//   bpp = util_format_get_blocksize(osbuffer->visual.color_format);
+//   if (osmesa->user_row_length)
+//      dst_stride = bpp * osmesa->user_row_length;
+//   else
+//      dst_stride = bpp * osbuffer->width;
+
+//   osmesa_read_buffer(osmesa, res, osbuffer->map, dst_stride, osmesa->y_up);
+
+   /* If the user has requested the Z/S buffer, then snapshot that one too. */
+//   if (osmesa->zs) {
+//      osmesa_read_buffer(osmesa, osbuffer->textures[ST_ATTACHMENT_DEPTH_STENCIL],
+//                         osmesa->zs, osmesa->zs_stride, true);
+//   }
+
+   return true;
+}
+
+
+#ifdef GALLIUM_ZINK
+static void
+osmesa_fill_private_loader_data(struct osmesa_buffer *osbuffer, struct kopper_loader_info *out)
+{
+#ifdef __ANDROID__
+   out->android.sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
+   out->android.pNext = NULL;
+   out->android.flags = 0;
+   out->android.window = osbuffer->map;
+#else
+   out->metal.sType = VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT;
+   out->metal.pNext = NULL;
+   out->metal.flags = 0;
+   out->metal.pLayer = osbuffer->map;
+#endif
+   assert(osbuffer->map);
+   //printf("osbuffer->map is %p\n", osbuffer->map);
+}
+#endif
+
+
+/**
+ * Called by the st manager to validate the framebuffer (allocate
+ * its resources).
+ */
+static bool
+osmesa_st_framebuffer_validate(struct st_context_iface *stctx,
+                               struct st_framebuffer_iface *stfbi,
+                               const enum st_attachment_type *statts,
+                               unsigned count,
+                               struct pipe_resource **out)
+{
+   struct pipe_screen *screen = get_st_manager()->screen;
+   enum st_attachment_type i;
+   struct osmesa_buffer *osbuffer = stfbi_to_osbuffer(stfbi);
+   struct pipe_resource templat;
+
+   memset(&templat, 0, sizeof(templat));
+   templat.target = PIPE_TEXTURE_RECT;
+   templat.format = 0; /* setup below */
+   templat.last_level = 0;
+   templat.width0 = osbuffer->width;
+   templat.height0 = osbuffer->height;
+   templat.depth0 = 1;
+   templat.array_size = 1;
+   templat.usage = PIPE_USAGE_DEFAULT;
+   templat.bind = 0; /* setup below */
+   templat.flags = 0;
+
+   for (i = 0; i < count; i++) {
+      enum pipe_format format = PIPE_FORMAT_NONE;
+      unsigned bind = 0;
+
+      if (statts[i] == ST_ATTACHMENT_FRONT_LEFT || statts[i] == ST_ATTACHMENT_BACK_LEFT) {
+         format = osbuffer->visual.color_format;
+         bind = PIPE_BIND_DISPLAY_TARGET |
+                PIPE_BIND_SAMPLER_VIEW |
+                PIPE_BIND_RENDER_TARGET;
+#ifdef GALLIUM_ZINK
+         //if (stw_dev->zink) {
+            /* Covers the case where we have already created a drawable that
+             * then got swapped and now we have to make a new back buffer.
+             * For Zink, we just alias the front buffer in that case.
+             */
+            if (i == ST_ATTACHMENT_BACK_LEFT && osbuffer->textures[ST_ATTACHMENT_FRONT_LEFT])
+               bind &= ~PIPE_BIND_DISPLAY_TARGET;
+         //}
+#endif
+      }
+      else if (statts[i] == ST_ATTACHMENT_DEPTH_STENCIL) {
+         format = osbuffer->visual.depth_stencil_format;
+         bind = PIPE_BIND_DEPTH_STENCIL;
+      }
+      else if (statts[i] == ST_ATTACHMENT_ACCUM) {
+         format = osbuffer->visual.accum_format;
+         bind = PIPE_BIND_RENDER_TARGET;
+      }
+      else {
+         debug_warning("Unexpected attachment type in "
+                       "osmesa_st_framebuffer_validate()");
+      }
+
+      templat.format = format;
+      templat.bind = bind;
+      pipe_resource_reference(&out[i], NULL);
+#ifdef GALLIUM_ZINK
+printf("create resource: statts[%d] = %d, screen->resource_create_drawable = %p, bind & PIPE_BIND_DISPLAY_TARGET = %d\n",
+i, statts[i], screen->resource_create_drawable, bind & PIPE_BIND_DISPLAY_TARGET);
+      if (statts[i] < ST_ATTACHMENT_DEPTH_STENCIL && screen->resource_create_drawable && osbuffer->map /* && is_window */) {
+         struct kopper_loader_info loader_info;
+         void *data;
+
+         if (bind & PIPE_BIND_DISPLAY_TARGET) {
+            osmesa_fill_private_loader_data(osbuffer, &loader_info);
+            data = &loader_info;
+         } else
+            data = osbuffer->textures[ST_ATTACHMENT_BACK_LEFT];
+
+         assert(data);
+         out[i] = osbuffer->textures[statts[i]] =
+            screen->resource_create_drawable(screen, &templat, data);
+      } else {
+#endif
+         out[i] = osbuffer->textures[statts[i]] =
+            screen->resource_create(screen, &templat);
+#ifdef GALLIUM_ZINK
+      }
+#endif
+   }
+
+   return true;
+}
+
+static uint32_t osmesa_fb_ID = 0;
+
+static struct st_framebuffer_iface *
+osmesa_create_st_framebuffer(void)
+{
+   struct st_framebuffer_iface *stfbi = CALLOC_STRUCT(st_framebuffer_iface);
+   if (stfbi) {
+      stfbi->flush_front = osmesa_st_framebuffer_flush_front;
+      stfbi->validate = osmesa_st_framebuffer_validate;
+      p_atomic_set(&stfbi->stamp, 1);
+      stfbi->ID = p_atomic_inc_return(&osmesa_fb_ID);
+      stfbi->state_manager = get_st_manager();
+   }
+   return stfbi;
+}
+
+
+/**
+ * Create new buffer and add to linked list.
+ */
+static struct osmesa_buffer *
+osmesa_create_buffer(enum pipe_format color_format,
+                     enum pipe_format ds_format,
+                     enum pipe_format accum_format)
+{
+   struct osmesa_buffer *osbuffer = CALLOC_STRUCT(osmesa_buffer);
+   if (osbuffer) {
+      osbuffer->stfb = osmesa_create_st_framebuffer();
+
+      osbuffer->stfb->st_manager_private = osbuffer;
+      osbuffer->stfb->visual = &osbuffer->visual;
+
+      osmesa_init_st_visual(&osbuffer->visual, color_format,
+                            ds_format, accum_format);
+   }
+
+   return osbuffer;
+}
+
+
+static void
+osmesa_destroy_buffer(struct osmesa_buffer *osbuffer)
+{
+   /*
+    * Notify the state manager that the associated framebuffer interface
+    * is no longer valid.
+    */
+   stapi->destroy_drawable(stapi, osbuffer->stfb);
+
+   FREE(osbuffer->stfb);
+   FREE(osbuffer);
+}
+
+
+
+/**********************************************************************/
+/*****                    Public Functions                        *****/
+/**********************************************************************/
+
+
+/**
+ * Create an Off-Screen Mesa rendering context.  The only attribute needed is
+ * an RGBA vs Color-Index mode flag.
+ *
+ * Input:  format - Must be GL_RGBA
+ *         sharelist - specifies another OSMesaContext with which to share
+ *                     display lists.  NULL indicates no sharing.
+ * Return:  an OSMesaContext or 0 if error
+ */
+GLAPI OSMesaContext GLAPIENTRY
+OSMesaCreateContext(GLenum format, OSMesaContext sharelist)
+{
+   return OSMesaCreateContextExt(format, 24, 8, 0, sharelist);
+}
+
+
+/**
+ * New in Mesa 3.5
+ *
+ * Create context and specify size of ancillary buffers.
+ */
+GLAPI OSMesaContext GLAPIENTRY
+OSMesaCreateContextExt(GLenum format, GLint depthBits, GLint stencilBits,
+                       GLint accumBits, OSMesaContext sharelist)
+{
+   int attribs[100], n = 0;
+
+   attribs[n++] = OSMESA_FORMAT;
+   attribs[n++] = format;
+   attribs[n++] = OSMESA_DEPTH_BITS;
+   attribs[n++] = depthBits;
+   attribs[n++] = OSMESA_STENCIL_BITS;
+   attribs[n++] = stencilBits;
+   attribs[n++] = OSMESA_ACCUM_BITS;
+   attribs[n++] = accumBits;
+   attribs[n++] = 0;
+
+   return OSMesaCreateContextAttribs(attribs, sharelist);
+}
+
+
+/**
+ * New in Mesa 11.2
+ *
+ * Create context with attribute list.
+ */
+GLAPI OSMesaContext GLAPIENTRY
+OSMesaCreateContextAttribs(const int *attribList, OSMesaContext sharelist)
+{
+   OSMesaContext osmesa;
+   struct st_context_iface *st_shared;
+   enum st_context_error st_error = 0;
+   struct st_context_attribs attribs;
+   struct st_api *stapi = get_st_api();
+   GLenum format = GL_RGBA;
+   int depthBits = 0, stencilBits = 0, accumBits = 0;
+   int profile = OSMESA_COMPAT_PROFILE, version_major = 1, version_minor = 0;
+   int i;
+
+   if (sharelist) {
+      st_shared = sharelist->stctx;
+   }
+   else {
+      st_shared = NULL;
+   }
+
+   for (i = 0; attribList[i]; i += 2) {
+      switch (attribList[i]) {
+      case OSMESA_FORMAT:
+         format = attribList[i+1];
+         switch (format) {
+         case OSMESA_COLOR_INDEX:
+         case OSMESA_RGBA:
+         case OSMESA_BGRA:
+         case OSMESA_ARGB:
+         case OSMESA_RGB:
+         case OSMESA_BGR:
+         case OSMESA_RGB_565:
+            /* legal */
+            break;
+         default:
+            return NULL;
+         }
+         break;
+      case OSMESA_DEPTH_BITS:
+         depthBits = attribList[i+1];
+         if (depthBits < 0)
+            return NULL;
+         break;
+      case OSMESA_STENCIL_BITS:
+         stencilBits = attribList[i+1];
+         if (stencilBits < 0)
+            return NULL;
+         break;
+      case OSMESA_ACCUM_BITS:
+         accumBits = attribList[i+1];
+         if (accumBits < 0)
+            return NULL;
+         break;
+      case OSMESA_PROFILE:
+         profile = attribList[i+1];
+         if (profile != OSMESA_CORE_PROFILE &&
+             profile != OSMESA_COMPAT_PROFILE)
+            return NULL;
+         break;
+      case OSMESA_CONTEXT_MAJOR_VERSION:
+         version_major = attribList[i+1];
+         if (version_major < 1)
+            return NULL;
+         break;
+      case OSMESA_CONTEXT_MINOR_VERSION:
+         version_minor = attribList[i+1];
+         if (version_minor < 0)
+            return NULL;
+         break;
+      case 0:
+         /* end of list */
+         break;
+      default:
+         fprintf(stderr, "Bad attribute in OSMesaCreateContextAttribs()\n");
+         return NULL;
+      }
+   }
+
+   osmesa = (OSMesaContext) CALLOC_STRUCT(osmesa_context);
+   if (!osmesa)
+      return NULL;
+
+   /* Choose depth/stencil/accum buffer formats */
+   if (accumBits > 0) {
+      osmesa->accum_format = PIPE_FORMAT_R16G16B16A16_SNORM;
+   }
+   if (depthBits > 0 && stencilBits > 0) {
+      osmesa->depth_stencil_format = PIPE_FORMAT_Z24_UNORM_S8_UINT;
+   }
+   else if (stencilBits > 0) {
+      osmesa->depth_stencil_format = PIPE_FORMAT_S8_UINT;
+   }
+   else if (depthBits >= 24) {
+      osmesa->depth_stencil_format = PIPE_FORMAT_Z24X8_UNORM;
+   }
+   else if (depthBits >= 16) {
+      osmesa->depth_stencil_format = PIPE_FORMAT_Z16_UNORM;
+   }
+
+   /*
+    * Create the rendering context
+    */
+   memset(&attribs, 0, sizeof(attribs));
+   attribs.profile = (profile == OSMESA_CORE_PROFILE)
+      ? ST_PROFILE_OPENGL_CORE : ST_PROFILE_DEFAULT;
+   attribs.major = version_major;
+   attribs.minor = version_minor;
+   attribs.flags = 0;  /* ST_CONTEXT_FLAG_x */
+   attribs.options.force_glsl_extensions_warn = FALSE;
+   attribs.options.disable_blend_func_extended = FALSE;
+   attribs.options.disable_glsl_line_continuations = FALSE;
+   attribs.options.force_glsl_version = 0;
+
+   osmesa_init_st_visual(&attribs.visual,
+                         PIPE_FORMAT_NONE,
+                         osmesa->depth_stencil_format,
+                         osmesa->accum_format);
+
+   osmesa->stctx = stapi->create_context(stapi, get_st_manager(),
+                                         &attribs, &st_error, st_shared);
+   if (!osmesa->stctx) {
+      FREE(osmesa);
+      return NULL;
+   }
+
+   osmesa->stctx->st_manager_private = osmesa;
+
+   osmesa->format = format;
+   osmesa->user_row_length = 0;
+   osmesa->y_up = GL_TRUE;
+
+   return osmesa;
+}
+
+
+
+/**
+ * Destroy an Off-Screen Mesa rendering context.
+ *
+ * \param osmesa  the context to destroy
+ */
+GLAPI void GLAPIENTRY
+OSMesaDestroyContext(OSMesaContext osmesa)
+{
+   if (osmesa) {
+      pp_free(osmesa->pp);
+      osmesa->stctx->destroy(osmesa->stctx);
+      free(osmesa->zs);
+      FREE(osmesa);
+   }
+}
+
+
+/**
+ * Bind an OSMesaContext to an image buffer.  The image buffer is just a
+ * block of memory which the client provides.  Its size must be at least
+ * as large as width*height*pixelSize.  Its address should be a multiple
+ * of 4 if using RGBA mode.
+ *
+ * By default, image data is stored in the order of glDrawPixels: row-major
+ * order with the lower-left image pixel stored in the first array position
+ * (ie. bottom-to-top).
+ *
+ * If the context's viewport hasn't been initialized yet, it will now be
+ * initialized to (0,0,width,height).
+ *
+ * Input:  osmesa - the rendering context
+ *         buffer - the image buffer memory
+ *         type - data type for pixel components
+ *                GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT
+ *                or GL_FLOAT.
+ *         width, height - size of image buffer in pixels, at least 1
+ * Return:  GL_TRUE if success, GL_FALSE if error because of invalid osmesa,
+ *          invalid type, invalid size, etc.
+ */
+GLAPI GLboolean GLAPIENTRY
+OSMesaMakeCurrent(OSMesaContext osmesa, void *buffer, GLenum type,
+                  GLsizei width, GLsizei height)
+{
+   struct st_api *stapi = get_st_api();
+   enum pipe_format color_format;
+
+   if (!osmesa && !buffer) {
+      stapi->make_current(stapi, NULL, NULL, NULL);
+      return GL_TRUE;
+   }
+
+   if (!osmesa /*|| !buffer*/ || width < 1 || height < 1) {
+      return GL_FALSE;
+   }
+
+   color_format = osmesa_choose_format(osmesa->format, type);
+   if (color_format == PIPE_FORMAT_NONE) {
+      fprintf(stderr, "OSMesaMakeCurrent(unsupported format/type)\n");
+      return GL_FALSE;
+   }
+
+   /* See if we already have a buffer that uses these pixel formats */
+   if (osmesa->current_buffer &&
+       (osmesa->current_buffer->visual.color_format != color_format ||
+        osmesa->current_buffer->visual.depth_stencil_format != osmesa->depth_stencil_format ||
+        osmesa->current_buffer->visual.accum_format != osmesa->accum_format ||
+        osmesa->current_buffer->width != width ||
+        osmesa->current_buffer->height != height)) {
+      osmesa_destroy_buffer(osmesa->current_buffer);
+      osmesa->current_buffer = NULL;
+   }
+
+   if (!osmesa->current_buffer) {
+      osmesa->current_buffer = osmesa_create_buffer(color_format,
+                                      osmesa->depth_stencil_format,
+                                      osmesa->accum_format);
+   }
+
+   struct osmesa_buffer *osbuffer = osmesa->current_buffer;
+
+   osbuffer->width = width;
+   osbuffer->height = height;
+   osbuffer->map = buffer;
+
+   osmesa->type = type;
+
+   stapi->make_current(stapi, osmesa->stctx, osbuffer->stfb, osbuffer->stfb);
+
+   /* XXX: We should probably load the current color value into the buffer here
+    * to match classic swrast behavior (context's fb starts with the contents of
+    * your pixel buffer).
+    */
+
+   if (!osmesa->ever_used) {
+      /* one-time init, just postprocessing for now */
+      boolean any_pp_enabled = FALSE;
+      unsigned i;
+
+      for (i = 0; i < ARRAY_SIZE(osmesa->pp_enabled); i++) {
+         if (osmesa->pp_enabled[i]) {
+            any_pp_enabled = TRUE;
+            break;
+         }
+      }
+
+      if (any_pp_enabled) {
+         osmesa->pp = pp_init(osmesa->stctx->pipe,
+                              osmesa->pp_enabled,
+                              osmesa->stctx->cso_context,
+                              osmesa->stctx);
+
+         pp_init_fbos(osmesa->pp, width, height);
+      }
+
+      osmesa->ever_used = TRUE;
+   }
+
+   return GL_TRUE;
+}
+
+
+
+GLAPI OSMesaContext GLAPIENTRY
+OSMesaGetCurrentContext(void)
+{
+   struct st_api *stapi = get_st_api();
+   struct st_context_iface *st = stapi->get_current(stapi);
+   return st ? (OSMesaContext) st->st_manager_private : NULL;
+}
+
+
+
+GLAPI void GLAPIENTRY
+OSMesaPixelStore(GLint pname, GLint value)
+{
+   OSMesaContext osmesa = OSMesaGetCurrentContext();
+
+   switch (pname) {
+   case OSMESA_ROW_LENGTH:
+      osmesa->user_row_length = value;
+      break;
+   case OSMESA_Y_UP:
+      osmesa->y_up = value ? GL_TRUE : GL_FALSE;
+      break;
+   default:
+      fprintf(stderr, "Invalid pname in OSMesaPixelStore()\n");
+      return;
+   }
+}
+
+
+GLAPI void GLAPIENTRY
+OSMesaGetIntegerv(GLint pname, GLint *value)
+{
+   OSMesaContext osmesa = OSMesaGetCurrentContext();
+   struct osmesa_buffer *osbuffer = osmesa ? osmesa->current_buffer : NULL;
+
+   switch (pname) {
+   case OSMESA_WIDTH:
+      *value = osbuffer ? osbuffer->width : 0;
+      return;
+   case OSMESA_HEIGHT:
+      *value = osbuffer ? osbuffer->height : 0;
+      return;
+   case OSMESA_FORMAT:
+      *value = osmesa->format;
+      return;
+   case OSMESA_TYPE:
+      /* current color buffer's data type */
+      *value = osmesa->type;
+      return;
+   case OSMESA_ROW_LENGTH:
+      *value = osmesa->user_row_length;
+      return;
+   case OSMESA_Y_UP:
+      *value = osmesa->y_up;
+      return;
+   case OSMESA_MAX_WIDTH:
+      FALLTHROUGH;
+   case OSMESA_MAX_HEIGHT:
+      {
+         struct pipe_screen *screen = get_st_manager()->screen;
+         *value = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_SIZE);
+      }
+      return;
+   default:
+      fprintf(stderr, "Invalid pname in OSMesaGetIntegerv()\n");
+      return;
+   }
+}
+
+
+/**
+ * Return information about the depth buffer associated with an OSMesa context.
+ * Input:  c - the OSMesa context
+ * Output:  width, height - size of buffer in pixels
+ *          bytesPerValue - bytes per depth value (2 or 4)
+ *          buffer - pointer to depth buffer values
+ * Return:  GL_TRUE or GL_FALSE to indicate success or failure.
+ */
+GLAPI GLboolean GLAPIENTRY
+OSMesaGetDepthBuffer(OSMesaContext c, GLint *width, GLint *height,
+                     GLint *bytesPerValue, void **buffer)
+{
+   struct osmesa_buffer *osbuffer = c->current_buffer;
+   struct pipe_resource *res = osbuffer->textures[ST_ATTACHMENT_DEPTH_STENCIL];
+
+   if (!res) {
+      *width = 0;
+      *height = 0;
+      *bytesPerValue = 0;
+      *buffer = NULL;
+      return GL_FALSE;
+   }
+
+   *width = res->width0;
+   *height = res->height0;
+   *bytesPerValue = util_format_get_blocksize(res->format);
+
+   if (!c->zs) {
+      c->zs_stride = *width * *bytesPerValue;
+      c->zs = calloc(c->zs_stride, *height);
+      if (!c->zs)
+         return GL_FALSE;
+
+      abort();
+      //osmesa_read_buffer(c, res, c->zs, c->zs_stride, true);
+   }
+
+   *buffer = c->zs;
+
+   return GL_TRUE;
+}
+
+
+/**
+ * Return the color buffer associated with an OSMesa context.
+ * Input:  c - the OSMesa context
+ * Output:  width, height - size of buffer in pixels
+ *          format - the pixel format (OSMESA_FORMAT)
+ *          buffer - pointer to color buffer values
+ * Return:  GL_TRUE or GL_FALSE to indicate success or failure.
+ */
+GLAPI GLboolean GLAPIENTRY
+OSMesaGetColorBuffer(OSMesaContext osmesa, GLint *width,
+                      GLint *height, GLint *format, void **buffer)
+{
+   struct osmesa_buffer *osbuffer = osmesa->current_buffer;
+
+   if (osbuffer) {
+      *width = osbuffer->width;
+      *height = osbuffer->height;
+      *format = osmesa->format;
+      *buffer = osbuffer->map;
+      return GL_TRUE;
+   }
+   else {
+      *width = 0;
+      *height = 0;
+      *format = 0;
+      *buffer = 0;
+      return GL_FALSE;
+   }
+}
+
+
+struct name_function
+{
+   const char *Name;
+   OSMESAproc Function;
+};
+
+static struct name_function functions[] = {
+   { "OSMesaCreateContext", (OSMESAproc) OSMesaCreateContext },
+   { "OSMesaCreateContextExt", (OSMESAproc) OSMesaCreateContextExt },
+   { "OSMesaCreateContextAttribs", (OSMESAproc) OSMesaCreateContextAttribs },
+   { "OSMesaDestroyContext", (OSMESAproc) OSMesaDestroyContext },
+   { "OSMesaMakeCurrent", (OSMESAproc) OSMesaMakeCurrent },
+   { "OSMesaGetCurrentContext", (OSMESAproc) OSMesaGetCurrentContext },
+   { "OSMesaPixelStore", (OSMESAproc) OSMesaPixelStore },
+   { "OSMesaGetIntegerv", (OSMESAproc) OSMesaGetIntegerv },
+   { "OSMesaGetDepthBuffer", (OSMESAproc) OSMesaGetDepthBuffer },
+   { "OSMesaGetColorBuffer", (OSMESAproc) OSMesaGetColorBuffer },
+   { "OSMesaGetProcAddress", (OSMESAproc) OSMesaGetProcAddress },
+   { "OSMesaColorClamp", (OSMESAproc) OSMesaColorClamp },
+   { "OSMesaPostprocess", (OSMESAproc) OSMesaPostprocess },
+   { "OSMesaFlushFrontbuffer", (OSMESAproc) OSMesaFlushFrontbuffer },
+   { NULL, NULL }
+};
+
+
+GLAPI OSMESAproc GLAPIENTRY
+OSMesaGetProcAddress(const char *funcName)
+{
+   int i;
+   for (i = 0; functions[i].Name; i++) {
+      if (strcmp(functions[i].Name, funcName) == 0)
+         return functions[i].Function;
+   }
+   return _glapi_get_proc_address(funcName);
+}
+
+
+GLAPI void GLAPIENTRY
+OSMesaColorClamp(GLboolean enable)
+{
+   extern void GLAPIENTRY _mesa_ClampColor(GLenum target, GLenum clamp);
+
+   _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR_ARB,
+                    enable ? GL_TRUE : GL_FIXED_ONLY_ARB);
+}
+
+
+GLAPI void GLAPIENTRY
+OSMesaPostprocess(OSMesaContext osmesa, const char *filter,
+                  unsigned enable_value)
+{
+   if (!osmesa->ever_used) {
+      /* We can only enable/disable postprocess filters before a context
+       * is made current for the first time.
+       */
+      unsigned i;
+
+      for (i = 0; i < PP_FILTERS; i++) {
+         if (strcmp(pp_filters[i].name, filter) == 0) {
+            osmesa->pp_enabled[i] = enable_value;
+            return;
+         }
+      }
+      debug_warning("OSMesaPostprocess(unknown filter)\n");
+   }
+   else {
+      debug_warning("Calling OSMesaPostprocess() after OSMesaMakeCurrent()\n");
+   }
+}
+
+
+GLAPI void GLAPIENTRY
+OSMesaFlushFrontbuffer() {
+   OSMesaContext osmesa = OSMesaGetCurrentContext();
+   osmesa_st_framebuffer_flush_front(osmesa->stctx, osmesa->current_buffer->stfb, ST_ATTACHMENT_BACK_LEFT);
+}
diff --git a/src/glx/empty.c b/src/glx/empty.c
new file mode 100644
index 0000000..e69de29
diff --git a/sync.pc b/sync.pc
new file mode 100644
index 0000000..521c3a8
--- /dev/null
+++ b/sync.pc
@@ -0,0 +1,4 @@
+Name: sync
+Description: Android libsync library
+Version: 1.0
+Libs:
diff --git a/vulkan_android.pc b/vulkan_android.pc
new file mode 100644
index 0000000..e112758
--- /dev/null
+++ b/vulkan_android.pc
@@ -0,0 +1,4 @@
+Name: vulkan
+Description: Android Vulkan library
+Version: 1.2
+Libs: -lvulkan
diff --git a/vulkan_ios.pc b/vulkan_ios.pc
new file mode 100644
index 0000000..4e8474a
--- /dev/null
+++ b/vulkan_ios.pc
@@ -0,0 +1,4 @@
+Name: vulkan
+Description: MoltenVK library
+Version: 1.2
+Libs: -L../ext -lMoltenVK
